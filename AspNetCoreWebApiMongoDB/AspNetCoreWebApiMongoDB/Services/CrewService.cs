using AspNetCoreWebApiMongoDB.Models;
using Microsoft.AspNetCore.Http;
using MongoDB.Bson;
using MongoDB.Bson.Serialization;
using MongoDB.Driver;
using MongoDB.Driver.GridFS;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace AspNetCoreWebApiMongoDB.Services
{
    public class CrewService
    {
        private readonly IMongoCollection<Crew> _crews;
        private readonly ProjectionDefinition<Crew> _projection;
        private readonly IMongoDatabase _db;

        public CrewService(MongoConnectionString connString)
        {
            var client = new MongoClient(connString.ConnectionString);
            this._db = client.GetDatabase(connString.DatabaseName);


            // to select only part of the fields we have to define projection,
            // without it we get an exception
            // id by default is included
            this._projection = Builders<Crew>.Projection
                .Include(c => c.CrewName)
                .Include(c => c.Skills);

            this._crews = this._db.GetCollection<Crew>("crew");
        }

        public List<Crew> GetCrews()
        {
            // just an example how to read only subset of fields:
            var tmpList = this._crews.Find(Builders<Crew>.Filter.Empty).Project(this._projection).ToList();
            foreach(var item in tmpList)
            {
               Debug.WriteLine(item.GetValue("name"));
            }

            return this._crews.Find(Builders<Crew>.Filter.Empty).ToList();
        }

        public Crew GetCrew(string id)
        {
            return this._crews.Find(c => c.Id == id).FirstOrDefault();
        }

        public Crew CreateCrew(Crew c)
        {
            this._crews.InsertOne(c);
            // after executing InsertOne Id is set on a new value generated by MongoDB
            return c;
        }

        public void Update(string id, Crew c)
        {
            // Set ID on the value equal to the ID of the document that we want to replace.
            // More here: https://chsakell.gitbook.io/mongodb-csharp-docs/crud-basics/update-documents/replace
            c.Id = id;

            // https://www.mongodb.com/community/forums/t/facing-this-weird-issue-in-asp-net-core-3-0/5057/2
            this._crews.ReplaceOne(c => c.Id == id, c);
        }

        public void Delete(string id)
        {
            // DeleteOne does not throw exception in case the object has not be found
            var results = this._crews.DeleteOne(c => c.Id == id);
            if (results.DeletedCount == 1)
            {
                Debug.WriteLine($"Delete object with id {id}");
            }
        }


        private GridFSBucket GetFileStorageBucket(string fileName)
        {
            // chunk size means amount for bytes that will be read from a stream: https://github.com/mongodb/mongo-csharp-driver/blob/master/src/MongoDB.Driver.GridFS/GridFSBucket.cs#L488
            // also it means size of chunk for storing the file in MongoDB, for example if we upload 30MB file and chunk is 1MB then 37 chunks will be created
            // in MongoDB to store this one file
            // so basically it is size for I/O operation
            var bucket = new GridFSBucket(this._db, new GridFSBucketOptions
            {
                BucketName = Path.GetExtension(fileName).Replace(".", ""),
                ChunkSizeBytes = 1048576, // 1MB
                WriteConcern = WriteConcern.WMajority,
                ReadPreference = ReadPreference.Secondary
            });
            return bucket;
        }

        public void SaveCrewFile(IFormFile formFile)
        {
            var bucket = this.GetFileStorageBucket(formFile.FileName);
            using (var stream = formFile.OpenReadStream())
            {
                bucket.UploadFromStream(formFile.FileName, stream);
            }
        }

        public void StoreNewFileVersion(IFormFile formFile, string version)
        {
            VersionedFileInfo versionedFileInfo = new VersionedFileInfo(formFile.FileName, version, formFile.ContentType, formFile.FileName, formFile.Length, DateTime.UtcNow);
            BsonDocument metadata = BsonDocument.Parse(JsonConvert.SerializeObject(versionedFileInfo));

            GridFSUploadOptions options = new GridFSUploadOptions()
            {
                Metadata = metadata,
            };

            var bucket = this.GetFileStorageBucket(formFile.FileName);

            // every time a new entry is created in DB, with this approach there is no way to update existing file
            // more in docs: https://docs.mongodb.com/manual/core/gridfs/
            // "Do not use GridFS if you need to update the content of the entire file atomically.
            // As an alternative you can store multiple versions of each file and specify the current version of
            // the file in the metadata. You can update the metadata field that indicates "latest" status in an atomic
            // update after uploading the new version of the file, and later remove previous versions if needed."
            bucket.UploadFromStream(formFile.FileName, formFile.OpenReadStream(), options);
        }

        public Stream DownloadFile(string fileName)
        {
            var bucket = this.GetFileStorageBucket(fileName);

            MemoryStream ms = new MemoryStream();
            bucket.DownloadToStreamByName(fileName, ms);

            // set stream position on 0 because by default it is set on the end of the stream!
            // it means that we read all data before we send the response to the client!
            ms.Position = 0;

            return ms;

        }

        public Stream DownloadFileUsingGridFSDownloadStream(string fileName)
        {
            FilterDefinitionBuilder<GridFSFileInfo> builder = Builders<GridFSFileInfo>.Filter;
            FilterDefinition<GridFSFileInfo> filter = builder.Eq(p => p.Filename, fileName);
            var bucket = this.GetFileStorageBucket(fileName);

            ObjectId streamId;
            using (IAsyncCursor<GridFSFileInfo> cursor = bucket.Find(filter))
            {
                GridFSFileInfo info = cursor.SingleOrDefault();
                if (info == null)
                {
                    return null;
                }
                streamId = info.Id;
            }

            // open stream should be used always for bigger files because then we can send data in chunks to the client
            // and we avoid huge memory allocation on the service side

            // it looks also that when we use File type as response in the endpoint the stream is automatically disposed
            // more info here: https://stackoverflow.com/questions/42238826/does-a-stream-get-disposed-when-returning-a-file-from-an-action
            // and for asp.net core it is also handled:
            // https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/FileStreamResult.cs#L79
            // https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/Infrastructure/FileStreamResultExecutor.cs#L40
            GridFSDownloadStream gridFSStream = bucket.OpenDownloadStream(streamId);

            return gridFSStream;
        }

        public VersionedFile DownloadVersionedFile(string fileName, string version)
        {
            FilterDefinitionBuilder<GridFSFileInfo> builder = Builders<GridFSFileInfo>.Filter;
            FilterDefinition<GridFSFileInfo> filter = builder.Eq(p => p.Filename, fileName)
                            & builder.Eq($"metadata.{nameof(VersionedFileInfo.VersionName)}", version);

            var bucket = this.GetFileStorageBucket(fileName);

            ObjectId streamId;
            using (IAsyncCursor<GridFSFileInfo> cursor = bucket.Find(filter))
            {
                // might throw exception: System.InvalidOperationException: Sequence contains more than one element
                //GridFSFileInfo info = cursor.SingleOrDefault();
                GridFSFileInfo info = cursor.FirstOrDefault();
                if (info == null)
                {
                    return null;
                }
                streamId = info.Id;
            }

            GridFSDownloadStream gridFSStream = bucket.OpenDownloadStream(streamId);
            VersionedFileInfo versionedFileInfo = BsonSerializer.Deserialize<VersionedFileInfo>(gridFSStream.FileInfo.Metadata);

            return new VersionedFile(gridFSStream, versionedFileInfo);
        }

    }
}
